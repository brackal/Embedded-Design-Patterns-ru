# MVC Pattern в монолитной встроенной системе (в разработке!)
## Основная идея
Как можно реализовать шаблон MVC в монолитной встроенной системе без дисплея? Какие компоненты могут выполнять роли Model, View и Controller?

Идея применения шаблона MVC (Model–View–Controller) во встроенных системах была заимствована из книги "Making Embedded Systems" Алисии Уайт. В открытых источниках доступно ограниченное количество информации о применении MVC во встроенном ПО.
Однако существует релевантная статья "Model View Controller Architecture on Embedded Systems" Абхишека Баджпаи.
Общее определение MVC также можно найти в книге "Pattern-Oriented Software Architecture" Франка Бушмана.
Роль Controller также можно вывести из принципов GRASP (General Responsibility Assignment Software Patterns).


## Обзор шаблона MVC
Шаблон MVC обычно описывается в контексте приложений с пользовательскими интерфейсами, включающими визуальные элементы, т.е. приложений с графическим интерфейсом (GUI).
Этот документ демонстрирует, как концепция MVC может быть реализована во встроенной системе без GUI.

Шаблон MVC определяет разделение ответственности между обработкой ввода, бизнес-логикой и генерацией вывода.
В следующих разделах описаны типовые роли компонентов в общей архитектуре MVC.

### Controller
• Получает ввод от пользователя, внешних источников или системных событий (во встроенных системах: нажатия кнопок, ввод с последовательного интерфейса, таймеры)<br>
• Интерпретирует ввод и вызывает соответствующие действия в Model<br>
• Управляет потоком управления и определяет, когда должны выполняться действия Model<br>

### Model
• Владеет и управляет системными данными и/или реализует основную бизнес-логику<br>
• Обеспечивает целостность и корректность данных<br>
• Уведомляет компонент View о изменениях данных<br>
• Определяет, как данные должны обрабатываться и поддерживаться<br>

### View
• Отображает данные пользователю или внешнему интерфейсу (во встроенных системах: светодиоды, вывод через последовательный интерфейс, индикаторы)<br>
• Форматирует данные для представления в соответствии с требованиями системы<br>

### Уведомление между Model и View с помощью шаблона Observer
Механизм уведомления между Model и Views может быть реализован с использованием шаблона Observer.
Все Views выступают в роли наблюдателей (observers) и должны подписываться на Model для данных, которые их интересуют.
При изменении соответствующих данных Model уведомляет всех подписанных наблюдателей, которые затем могут получить обновленные данные и отобразить их.
См. [Observer Pattern](https://github.com/brackal/Head-First-Design-Patterns-Cpp) и [Callback Pattern](https://github.com/brackal/Embedded-Design-Patterns/tree/main/CallbackPattern)

### Итог
В итоге, шаблон MVC обеспечивает чёткое разделение ответственности в проектировании ПО.
При применении во встроенных системах он помогает изолировать аппаратно-зависимую обработку ввода/вывода (Controller и View) от основной логики (Model), улучшая модульность, поддерживаемость и тестируемость.


## Взаимодействие Controller–Model–View в контексте встроенной системы
Controller получает ввод от пользователя или других систем.
В этом примере ввод генерируется либо нажатием кнопки, либо сообщением (telegram) через последовательный интерфейс. Каждый тип ввода обрабатывается отдельным Controller.

Controllers интерпретируют входные данные и определяют, какие данные нужно изменить в Model.
У них есть как права на чтение, так и на запись модели, и они запускают соответствующие действия по мере необходимости.
В некоторых случаях Controllers также должны получать данные из Model; в таких случаях они могут напрямую обращаться к необходимой информации.<br>
Controllers также имеют доступ к Views и могут при необходимости инициировать визуализацию или отображение данных.

Model (может состоять из одной сущности или, как в этом примере, из нескольких подмоделей) уведомляет всех подписанных Views при изменении своих данных или состояния.

При получении такого уведомления каждый View — который должен иметь только права на чтение модели — получает соответствующие данные, представляя их в нужном виде.<br>
В этом примере светодиод (LED) функционирует как визуальный элемент. Передача информации сама по себе может рассматриваться как форма представления данных.

##### Нотация диаграммы и семантика стрелок
На диаграмме стрелки со стереотипом << flow >> представляют поток информации от источника к приёмнику.
Они не указывают на структурную зависимость. Например, Button не зависит от Controller.
Стрелки со стереотипом << use >> указывают на реальную структурную зависимость.<br>
Например, Controller зависит от Model, что означает, что в реализации Controller должен держать ссылку на Model.

![MVC - Roles in Embedded Context](uml/MVC-Roles_in_Embedded_Context.PNG "MVC Roles in Embedded Context")


## Расширение MVC для учета сложности встроенных систем
Сначала всё было относительно просто. Теперь ситуация усложняется.
Как должны быть реализованы компоненты, такие как датчики (Sensor) или постоянное хранилище (Persistence)?
Какой компонент MVC отвечает за взаимодействие с этими элементами?

**Specifically:**<br>
• Является ли задачей Controller запуск измерения датчика и чтение данных, или это ответственность Model?<br>
• Какой компонент должен управлять постоянными данными: Controller или Model?

Эти вопросы необходимо тщательно рассмотреть, чтобы обеспечить чёткое разделение ответственности, модульность и поддерживаемость архитектуры системы.

### Активные и пассивные модели
Эти вопросы можно решить, поняв, что Model может быть либо активной, либо пассивной.

#### Пассивная модель
Пассивная модель — это чисто модель данных: она хранит данные и может выполнять базовые вычисления.
Пассивная модель не имеет доступа к нижним уровням системы.

**Use Case: Sensor**<br>
• Sensor Controller определяет, когда нужно сделать измерение.<br>
• Sensor Controller инициирует измерение на датчике и считывает результаты.<br>
• Sensor Controller затем обновляет соответствующее значение в Sensor Model (например, температуру).<br>
• Model уведомляет подписанных наблюдателей, например Communication View, чтобы значение могло быть передано через последовательный интерфейс.

**Use Case: Persistence**<br>
• NVM Controller определяет, когда данные должны быть прочитаны из постоянного хранилища, и обновляет соответствующую NVM Model.<br>
• Model уведомляет подписанных NVM Observers (термин «observer» используется для отличия от View).<br>
• NVM Observer записывает данные в постоянное хранилище.

**In summary:**<br>
• Controller читает данные с датчиков или из постоянного хранилища.<br>
• Observer записывает данные в постоянное хранилище или обрабатывает их передачу.

![MVC - Passive Model](uml/MVC-Passive_Model.PNG "Passive Model")

#### Активная модель
Активная модель имеет прямой доступ к компонентам нижнего уровня системы.

**Use Case: Sensor**<br>
• Sensor Controller определяет, когда нужно сделать измерение (например, каждые 60 секунд).<br>
• Sensor Controller вызывает соответствующее действие на Sensor Model (например, Model.SensorModel.DoMeasurement()).<br>
• Sensor Model самостоятельно инициирует измерение на датчике и считывает результаты.<br>
• После обновления своих данных Model уведомляет подписанных наблюдателей, например Communication View, чтобы значения могли быть переданы через последовательный интерфейс.

**Use Case: Persistence**<br>
• NVM Model самостоятельно определяет, когда данные должны быть прочитаны или записаны в постоянное хранилище, и выполняет эти операции самостоятельно.<br>
• В этом случае ни NVM Controller, ни NVM Observers не требуются.

![MVC - Active Model](uml/MVC-Active_Model.PNG "Active Model")


## Вид слоёв
![Layer](uml/Layer.PNG "Layer View")

## todo
