# MVC Pattern в монолитной встроенной системе (в разработке!)
## Main Idea

Как можно реализовать шаблон MVC в монолитной встроенной системе без дисплея? Какие компоненты могут выполнять роли Model, View и Controller?

Идея применения шаблона MVC (Model–View–Controller) во встроенных системах была заимствована из книги "Making Embedded Systems" Алисии Уайт. В открытых источниках доступно ограниченное количество информации о применении MVC во встроенном ПО.
Однако существует релевантная статья "Model View Controller Architecture on Embedded Systems" Абхишека Баджпаи.
Общее определение MVC также можно найти в книге "Pattern-Oriented Software Architecture" Франка Бушмана.
Роль Controller также можно вывести из принципов GRASP (General Responsibility Assignment Software Patterns).

## Overview of the MVC Pattern

Шаблон MVC обычно описывается в контексте приложений с пользовательскими интерфейсами, включающими визуальные элементы, т.е. приложений с графическим интерфейсом (GUI).
Этот документ демонстрирует, как концепция MVC может быть реализована во встроенной системе без GUI.

Шаблон MVC определяет разделение ответственности между обработкой ввода, бизнес-логикой и генерацией вывода.
В следующих разделах описаны типовые роли компонентов в общей архитектуре MVC.

### Controller

• Получает ввод от пользователя, внешних источников или системных событий (во встроенных системах: нажатия кнопок, ввод с последовательного интерфейса, таймеры)<br>
• Интерпретирует ввод и вызывает соответствующие действия в Model<br>
• Управляет потоком управления и определяет, когда должны выполняться действия Model<br>

### Model

• Владеет и управляет системными данными и/или реализует основную бизнес-логику<br>
• Обеспечивает целостность и корректность данных<br>
• Уведомляет компонент View о изменениях данных<br>
• Определяет, как данные должны обрабатываться и поддерживаться<br>

### View

• Отображает данные пользователю или внешнему интерфейсу (во встроенных системах: светодиоды, вывод через последовательный интерфейс, индикаторы)<br>
• Форматирует данные для представления в соответствии с требованиями системы<br>

### Model–View Notification via Observer Pattern

Механизм уведомления между Model и Views может быть реализован с использованием шаблона Observer.
Все Views выступают в роли наблюдателей (observers) и должны подписываться на Model для данных, которые их интересуют.
При изменении соответствующих данных Model уведомляет всех подписанных наблюдателей, которые затем могут получить обновленные данные и отобразить их.
См. Observer Pattern

### Summary

В итоге, шаблон MVC обеспечивает чёткое разделение ответственности в проектировании ПО.
При применении во встроенных системах он помогает изолировать аппаратно-зависимую обработку ввода/вывода (Controller и View) от основной логики (Model), улучшая модульность, поддерживаемость и тестируемость.

## Controller-Model–View Interaction in Embedded Context

Controller получает ввод от пользователя или других систем.
В этом примере ввод генерируется либо нажатием кнопки, либо сообщением (telegram) через последовательный интерфейс. Каждый тип ввода обрабатывается отдельным Controller.

Controllers интерпретируют входные данные и определяют, какие данные нужно изменить в Model.
Они имеют чтение и запись в Model и инициируют соответствующие действия по мере необходимости.
В некоторых случаях Controllers также должны получать данные из Model; в таких случаях они могут напрямую обращаться к необходимой информации.<br>
Controllers также имеют доступ к Views и могут при необходимости инициировать визуализацию или отображение данных.

Model (может состоять из одной сущности или, как в этом примере, из нескольких подмоделей) уведомляет всех подписанных Views при изменении своих данных или состояния.

После получения такого уведомления каждый View — который должен иметь только чтение из Model — получает соответствующие данные и отображает их.<br>
В этом примере светодиод (LED) функционирует как визуальный элемент. Передача информации сама по себе может рассматриваться как форма представления данных.

##### Diagram Notation and Arrow Semantics

На диаграмме стрелки со стереотипом <<flow>> представляют поток информации от источника к приёмнику.
Они не указывают на структурную зависимость. Например, кнопка не зависит от Controller.
Стрелки со стереотипом <<use>> указывают на реальную структурную зависимость.<br>
Например, Controller зависит от Model, что означает, что в реализации Controller должен держать ссылку на Model.


## Extending MVC for Embedded System Complexity

Сначала всё было относительно просто. Теперь ситуация усложняется.
Как должны быть реализованы компоненты, такие как датчики или постоянное хранилище?
Какой компонент MVC отвечает за взаимодействие с этими элементами?

Specifically: <br>
• Является ли задачей Controller запуск измерения датчика и чтение данных, или это ответственность Model?<br>
• Какой компонент должен управлять постоянными данными: Controller или Model?

Эти вопросы необходимо тщательно рассмотреть, чтобы обеспечить чёткое разделение ответственности, модульность и поддерживаемость архитектуры системы.

### Active vs. Passive Models

Эти вопросы можно решить, поняв, что Model может быть либо активной, либо пассивной.

#### Passive Model

Пассивная модель — это чисто модель данных: она хранит данные и может выполнять базовые вычисления.
Пассивная модель не имеет доступа к нижним уровням системы.

Use Case: Sensor<br>
• Sensor Controller определяет, когда нужно сделать измерение.<br>
• Sensor Controller инициирует измерение на датчике и считывает результаты.<br>
• Sensor Controller затем обновляет соответствующее значение в Sensor Model (например, температуру).<br>
• Model уведомляет подписанных наблюдателей, например Communication View, чтобы значение могло быть передано через последовательный интерфейс.

Use Case: Persistence<br>
• NVM Controller определяет, когда данные должны быть прочитаны из постоянного хранилища, и обновляет соответствующую NVM Model.<br>
• Model уведомляет подписанных NVM Observers (термин «observer» используется для отличия от View).<br>
• NVM Observer записывает данные в постоянное хранилище.

In summary:<br>
• Controller читает данные с датчиков или из постоянного хранилища.<br>
• Observer записывает данные в постоянное хранилище или обрабатывает их передачу.
